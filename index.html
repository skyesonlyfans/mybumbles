<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Bumbles</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/icon?family=Material+Icons|Material+Icons+Outlined" rel="stylesheet">
    <style>
        :root {
            --sky-top: #0c4a6e;
            --sky-horizon: #38bdf8;
            --ground-color: #1e293b;
        }
        html, body {
            height: 100%;
            width: 100%;
            overflow: hidden;
            position: fixed;
        }
        body {
            font-family: 'Inter', sans-serif;
            background-color: #020617;
            color: #e2e8f0;
            overscroll-behavior: none;
        }
        #simulation-container {
            width: 100dvw;
            height: 100dvh;
            transition: background 2s ease-in-out;
        }
        .glassmorphism {
            background: rgba(30, 41, 59, 0.5);
            backdrop-filter: blur(16px);
            -webkit-backdrop-filter: blur(16px);
            border: 1px solid rgba(71, 85, 105, 0.5);
            box-shadow: 0 8px 32px 0 rgba(0, 0, 0, 0.37);
        }
        .control-btn {
            transition: all 0.3s ease;
            border: 1px solid transparent;
            background-image: linear-gradient(to bottom right, var(--tw-gradient-stops));
            box-shadow: 0 0 8px rgba(59, 130, 246, 0.3), 0 0 15px rgba(59, 130, 246, 0.2), inset 0 1px 1px 0 rgba(255,255,255,0.1);
        }
        .control-btn:hover {
            transform: translateY(-3px) scale(1.05);
            box-shadow: 0 0 20px rgba(59, 130, 246, 0.6), 0 0 40px rgba(59, 130, 246, 0.4), inset 0 1px 1px 0 rgba(255,255,255,0.2);
            border-color: rgba(96, 165, 250, 0.5);
        }
        .control-btn:active { transform: translateY(-1px) scale(1.02); }
        .control-btn.active {
             border-color: rgba(96, 165, 250, 0.8);
             transform: translateY(1px) scale(0.98);
             box-shadow: inset 0 3px 7px rgba(0,0,0,0.4), 0 0 10px rgba(59, 130, 246, 0.6);
        }
        #play-pause-btn.paused { animation: pulse 2s infinite; }
        @keyframes pulse {
            0%, 100% { transform: scale(1); box-shadow: 0 0 8px rgba(59, 130, 246, 0.3), 0 0 15px rgba(59, 130, 246, 0.2); }
            50% { transform: scale(1.05); box-shadow: 0 0 20px rgba(59, 130, 246, 0.6), 0 0 40px rgba(59, 130, 246, 0.4); }
        }
        .modal-enter { animation: fadeInScale 0.4s cubic-bezier(0.165, 0.840, 0.440, 1.000) forwards; }
        @keyframes fadeInScale {
            from { opacity: 0; transform: scale(0.92); }
            to { opacity: 1; transform: scale(1); }
        }
        .modal-wrapper {
            transition: opacity 0.3s ease, visibility 0.3s;
            opacity: 0;
            visibility: hidden;
        }
        .modal-wrapper.visible {
            opacity: 1;
            visibility: visible;
        }
        canvas { display: block; width: 100%; height: 100%; touch-action: none; cursor: grab; }
        canvas:active { cursor: grabbing; }
        .draggable {
            position: absolute;
            z-index: 10;
            user-select: none;
        }
        .drag-handle {
            cursor: grab;
            padding: 4px;
            background-color: rgba(71, 85, 105, 0.5);
            border-bottom: 1px solid rgba(71, 85, 105, 0.8);
        }
        .drag-handle:active { cursor: grabbing; }
        #start-screen {
            transition: opacity 0.5s ease-out;
        }
        #stats-panel-content {
            transition: all 0.5s ease-in-out, grid-template-rows 0.5s step-end;
            overflow: hidden;
            display: grid;
            grid-template-rows: 1fr;
        }
        #stats-panel.collapsed #stats-panel-content {
            grid-template-rows: 0fr;
            transition: all 0.5s ease-in-out, grid-template-rows 0.5s step-start;
            padding-top: 0;
            padding-bottom: 0;
        }
        #family-list-stat {
            max-height: 60px;
            overflow-y: auto;
        }
    </style>
</head>
<body class="overflow-hidden h-screen w-screen flex items-center justify-center">

    <div id="simulation-container" class="relative w-full h-full">
        <canvas id="simulationCanvas"></canvas>

        <!-- UI Panels -->
        <div id="stats-panel" class="draggable glassmorphism rounded-lg text-xs md:text-sm w-56" style="top: 1rem; right: 1rem;">
            <div class="drag-handle rounded-t-lg text-center text-slate-300 font-bold flex justify-between items-center pr-2">
                <span class="flex-grow text-center">Statistics</span>
                 <button id="collapse-stats-btn" class="p-1 rounded-full hover:bg-slate-600/50">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4 text-slate-300 transition-transform duration-300" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7" /></svg>
                </button>
            </div>
            <div id="stats-panel-content" class="p-3">
                <div class="min-h-0">
                    <div class="grid grid-cols-2 gap-x-4 gap-y-1">
                        <p>Population:</p><p class="text-right"><span id="population-stat" class="font-semibold text-white">0</span></p>
                        <p>Day:</p><p class="text-right"><span id="day-stat" class="font-semibold text-white">0</span> (<span id="time-of-day-stat">Day</span>)</p>
                        <p>Cities:</p><p class="text-right"><span id="cities-stat" class="font-semibold text-white">0</span></p>
                    </div>
                    <div class="border-t border-slate-600 my-2"></div>
                    <p>Families (<span id="families-count-stat">0</span>):</p>
                    <div id="family-list-stat" class="text-right text-slate-300 text-xs italic pr-1">None</div>
                </div>
            </div>
        </div>
        
        <div id="tool-panel" class="draggable flex flex-col gap-2" style="top: 50%; left: 1rem; transform: translateY(-50%);">
             <button data-tool="bumble" title="Place Bumble" class="tool-btn control-btn from-purple-500 to-purple-700 text-white p-3 rounded-full w-12 h-12 flex items-center justify-center"><span class="material-icons-outlined text-2xl">person_add</span></button>
             <button data-tool="food" title="Place Food" class="tool-btn control-btn from-green-500 to-green-700 text-white p-3 rounded-full w-12 h-12 flex items-center justify-center"><span class="material-icons-outlined text-2xl">grass</span></button>
             <button data-tool="tree" title="Place Tree" class="tool-btn control-btn from-yellow-600 to-yellow-800 text-white p-3 rounded-full w-12 h-12 flex items-center justify-center"><span class="material-icons-outlined text-2xl">forest</span></button>
             <button data-tool="fire" title="Place Fire" class="tool-btn control-btn from-red-500 to-red-700 text-white p-3 rounded-full w-12 h-12 flex items-center justify-center"><span class="material-icons-outlined text-2xl">local_fire_department</span></button>
        </div>

        <!-- Bottom Control Bar -->
        <div class="absolute bottom-0 left-0 right-0 p-4 flex justify-center items-center gap-2 z-10">
            <button id="restart-btn" title="Restart" class="control-btn from-slate-600 to-slate-800 text-white font-bold p-3 rounded-full w-14 h-14 flex items-center justify-center"><span class="material-icons-outlined text-3xl">restart_alt</span></button>
            <button id="play-pause-btn" class="control-btn from-blue-500 to-blue-700 text-white font-bold p-3 rounded-full w-16 h-16 flex items-center justify-center paused">
                <span id="play-icon" class="material-icons text-5xl">play_arrow</span>
                <span id="pause-icon" class="material-icons text-5xl hidden">pause</span>
            </button>
            <button id="zombie-btn" title="Spawn Zombie" class="control-btn from-green-700 to-green-900 text-white font-bold p-3 rounded-full w-14 h-14 flex items-center justify-center"><span class="material-icons text-3xl">coronavirus</span></button>
            <button id="settings-btn" title="Settings" class="control-btn from-slate-600 to-slate-800 text-white font-bold p-3 rounded-full w-14 h-14 flex items-center justify-center"><span class="material-icons-outlined text-3xl">settings</span></button>
        </div>
    </div>

    <!-- Modals -->
    <div id="bumble-info-modal" class="modal-wrapper absolute inset-0 bg-black bg-opacity-60 flex items-center justify-center z-20 p-4">
        <div class="glassmorphism rounded-2xl w-full max-w-sm p-6 text-center modal-enter">
            <h2 id="bumble-name" class="text-3xl font-bold bg-clip-text text-transparent bg-gradient-to-r from-pink-400 to-blue-400 mb-1"></h2>
            <p class="text-slate-400 mb-4">Generation <span id="bumble-generation"></span></p>
            <div class="grid grid-cols-2 gap-4 text-left">
                <div class="bg-slate-900/50 p-3 rounded-lg"><p class="text-xs text-slate-400">Gender</p><p id="bumble-gender" class="font-semibold text-lg"></p></div>
                <div class="bg-slate-900/50 p-3 rounded-lg"><p class="text-xs text-slate-400">Age</p><p id="bumble-age" class="font-semibold text-lg"></p></div>
                <div class="bg-slate-900/50 p-3 rounded-lg col-span-2"><p class="text-xs text-slate-400">Hunger</p><div class="w-full bg-slate-700 rounded-full h-2.5 mt-1"><div id="bumble-energy-bar" class="bg-green-500 h-2.5 rounded-full"></div></div></div>
                <div class="bg-slate-900/50 p-3 rounded-lg"><p class="text-xs text-slate-400">Current State</p><p id="bumble-occupation" class="font-semibold"></p></div>
                <div class="bg-slate-900/50 p-3 rounded-lg"><p class="text-xs text-slate-400">Holding</p><p id="bumble-holding" class="font-semibold"></p></div>
            </div>
            <button id="close-info-btn" class="mt-6 w-full bg-gradient-to-r from-blue-600 to-blue-800 hover:from-blue-500 hover:to-blue-700 text-white font-semibold py-2 px-4 rounded-lg transition-all duration-300">Close</button>
        </div>
    </div>
    <div id="settings-modal" class="modal-wrapper absolute inset-0 bg-black bg-opacity-60 flex items-center justify-center z-20 p-4">
        <div class="glassmorphism rounded-2xl w-full max-w-sm p-6 modal-enter">
            <h2 class="text-2xl font-bold text-white mb-4">Simulation Settings</h2>
            <div class="space-y-4">
                <div><label for="initial-pop-slider" class="block mb-1 text-sm font-medium text-slate-300">Initial Population: <span id="initial-pop-value">6</span></label><input id="initial-pop-slider" type="range" min="2" max="100" value="6" class="w-full h-2 bg-slate-700 rounded-lg appearance-none cursor-pointer"></div>
                <div><label for="food-interval-slider" class="block mb-1 text-sm font-medium text-slate-300">Food Spawn Rate: <span id="food-interval-value">100</span></label><input id="food-interval-slider" type="range" min="10" max="500" value="100" class="w-full h-2 bg-slate-700 rounded-lg appearance-none cursor-pointer"></div>
                <div><label for="reproduction-rate-slider" class="block mb-1 text-sm font-medium text-slate-300">Reproduction Urge: <span id="reproduction-rate-value">50</span>%</label><input id="reproduction-rate-slider" type="range" min="0" max="100" value="50" class="w-full h-2 bg-slate-700 rounded-lg appearance-none cursor-pointer"></div>
                <div><label for="mutation-rate-slider" class="block mb-1 text-sm font-medium text-slate-300">Mutation Chance: <span id="mutation-rate-value">5</span>%</label><input id="mutation-rate-slider" type="range" min="0" max="50" value="5" class="w-full h-2 bg-slate-700 rounded-lg appearance-none cursor-pointer"></div>
                <div><label for="time-speed-slider" class="block mb-1 text-sm font-medium text-slate-300">Time Speed: <span id="time-speed-value">1</span>x</label><input id="time-speed-slider" type="range" min="1" max="10" value="1" class="w-full h-2 bg-slate-700 rounded-lg appearance-none cursor-pointer"></div>
            </div>
            <p class="text-xs text-slate-400 mt-4">Population/Rate changes apply on restart.</p>
            <button id="close-settings-btn" class="mt-4 w-full bg-gradient-to-r from-blue-600 to-blue-800 hover:from-blue-500 hover:to-blue-700 text-white font-semibold py-2 px-4 rounded-lg transition-all duration-300">Close</button>
        </div>
    </div>

    <!-- Start Screen -->
    <div id="start-screen" class="absolute inset-0 bg-black bg-opacity-80 z-30 flex items-center justify-center cursor-pointer">
        <div class="text-center">
            <h1 class="text-4xl font-bold text-amber-300 animate-pulse">Do not overfeed the bumbles</h1>
            <p class="text-slate-300 mt-2">- you have been warned! -</p>
            <p class="text-slate-400 mt-8 text-lg">(tap to start)</p>
        </div>
    </div>

<script>
document.addEventListener('DOMContentLoaded', () => {
    // --- DOM ELEMENT SELECTION ---
    const canvas = document.getElementById('simulationCanvas'), ctx = canvas.getContext('2d');
    const simulationContainer = document.getElementById('simulation-container');
    const playPauseBtn = document.getElementById('play-pause-btn'), playIcon = document.getElementById('play-icon'), pauseIcon = document.getElementById('pause-icon');
    const restartBtn = document.getElementById('restart-btn'), settingsBtn = document.getElementById('settings-btn'), zombieBtn = document.getElementById('zombie-btn');
    const populationStat = document.getElementById('population-stat'), dayStat = document.getElementById('day-stat'), timeOfDayStat = document.getElementById('time-of-day-stat'), citiesStat = document.getElementById('cities-stat'), familiesCountStat = document.getElementById('families-count-stat'), familyListStat = document.getElementById('family-list-stat');
    const statsPanel = document.getElementById('stats-panel'), collapseStatsBtn = document.getElementById('collapse-stats-btn');
    const bumbleInfoModal = document.getElementById('bumble-info-modal'), closeInfoBtn = document.getElementById('close-info-btn'), bumbleName = document.getElementById('bumble-name'), bumbleGeneration = document.getElementById('bumble-generation'), bumbleGender = document.getElementById('bumble-gender'), bumbleAge = document.getElementById('bumble-age'), bumbleEnergyBar = document.getElementById('bumble-energy-bar'), bumbleOccupation = document.getElementById('bumble-occupation'), bumbleHolding = document.getElementById('bumble-holding');
    const settingsModal = document.getElementById('settings-modal'), closeSettingsBtn = document.getElementById('close-settings-btn'), initialPopSlider = document.getElementById('initial-pop-slider'), foodIntervalSlider = document.getElementById('food-interval-slider'), reproductionRateSlider = document.getElementById('reproduction-rate-slider'), mutationRateSlider = document.getElementById('mutation-rate-slider'), timeSpeedSlider = document.getElementById('time-speed-slider'), initialPopValue = document.getElementById('initial-pop-value'), foodIntervalValue = document.getElementById('food-interval-value'), reproductionRateValue = document.getElementById('reproduction-rate-value'), mutationRateValue = document.getElementById('mutation-rate-value'), timeSpeedValue = document.getElementById('time-speed-value');
    const toolBtns = document.querySelectorAll('.tool-btn');
    const startScreen = document.getElementById('start-screen');

    // --- SIMULATION & VIEW STATE ---
    let bumbles = [], foods = [], resources = [], cities = [];
    let isRunning = false, animationFrameId, day = 0, frameCount = 0;
    const framesPerDay = 6000; 
    let timeOfDay = 'Day';
    let worldStats = { deaths: 0, mutations: 0 };
    let activeTool = null;
    let settings = { initialPopulation: 6, foodSpawnInterval: 100, reproductionUrge: 0.5, mutationChance: 0.05, timeMultiplier: 1 };
    
    let camera = { x: 0, y: 0, scale: 1, isPanning: false, lastPanX: 0, lastPanY: 0, lastTouchDist: 0 };

    // --- UTILITY & NAME FUNCTIONS ---
    const random = (min, max) => Math.random() * (max - min) + min;
    const getDistance = (x1, y1, x2, y2) => Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));
    const maleNames = ["Liam", "Noah", "Oliver", "Elijah", "James"], femaleNames = ["Olivia", "Emma", "Charlotte", "Amelia", "Ava"], lastNames = ["Smith", "Jones", "Garcia", "Miller", "Davis"];
    const cityPrefixes = ["Green", "Stone", "River", "Sun", "Moon"], citySuffixes = ["wood", "field", "dale", "crest", "ford"];
    const getRandomFirstName = (gender) => gender === 'male' ? maleNames[Math.floor(random(0, maleNames.length))] : femaleNames[Math.floor(random(0, femaleNames.length))];
    const getRandomLastName = () => lastNames[Math.floor(random(0, lastNames.length))];
    const generateCityName = () => `${cityPrefixes[Math.floor(random(0, cityPrefixes.length))]} ${citySuffixes[Math.floor(random(0, citySuffixes.length))]}`;

    // --- CLASSES ---
    class WorldObject { constructor(x, y) { this.x = x; this.y = y; this.id = Math.random().toString(36).substr(2, 9); } }
    class Food extends WorldObject {
        constructor(x, y) { super(x, y); this.radius = 4; this.energy = 50; this.pulse = random(0, Math.PI * 2); }
        draw() { this.pulse += 0.05; const glow = 8 + Math.sin(this.pulse) * 4; ctx.beginPath(); ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2); ctx.fillStyle = 'rgba(134, 239, 172, 0.9)'; ctx.shadowColor = 'rgba(134, 239, 172, 0.8)'; ctx.shadowBlur = glow; ctx.fill(); ctx.shadowBlur = 0; }
    }
    class Fire extends WorldObject {
        constructor(x, y) { super(x, y); this.radius = 15; this.damage = 0.5; this.particles = []; }
        update() { if (Math.random() < 0.8) this.particles.push({ x: this.x + random(-8, 8), y: this.y, life: 1, vx: random(-0.2, 0.2), vy: random(-1.5, -0.8), radius: random(2, 5) }); this.particles.forEach(p => { p.life -= 0.04; p.x += p.vx; p.y += p.vy; }); this.particles = this.particles.filter(p => p.life > 0); }
        draw() { this.particles.forEach(p => { ctx.beginPath(); const a = p.life, r = 255, g = Math.floor(255 * (p.life * 0.5 + 0.5)), b = 0; ctx.fillStyle = `rgba(${r},${g},${b},${a})`; ctx.arc(p.x, p.y, p.radius * p.life, 0, Math.PI * 2); ctx.fill(); }); }
    }
    class Tree extends WorldObject {
        constructor(x, y) {
            super(x, y);
            this.radius = random(8, 12);
            this.woodAmount = 3;
        }
        draw() {
            ctx.fillStyle = '#8B4513';
            ctx.fillRect(this.x - this.radius * 0.2, this.y, this.radius * 0.4, this.radius);
            ctx.fillStyle = '#228B22';
            ctx.beginPath();
            ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
            ctx.fill();
        }
    }
    class Structure extends WorldObject {
        constructor(x, y, type) { super(x, y); this.type = type; this.buildProgress = 0; this.requiredWood = type === 'dwelling' ? 5 : 15; this.isComplete = false; }
        addWood() { this.buildProgress++; if (this.buildProgress >= this.requiredWood) this.isComplete = true; }
        draw() {
            const progressRatio = this.buildProgress / this.requiredWood;
            ctx.globalAlpha = 0.5 + progressRatio * 0.5;
            if (this.type === 'dwelling') {
                const size = 10 + 5 * progressRatio;
                ctx.fillStyle = '#a16207'; ctx.fillRect(this.x - size / 2, this.y - size / 2, size, size);
            } else if (this.type === 'monument') {
                const radius = 8 + 7 * progressRatio;
                ctx.fillStyle = '#fde047'; ctx.beginPath(); ctx.arc(this.x, this.y, radius, 0, Math.PI * 2); ctx.fill();
            }
            ctx.globalAlpha = 1;
        }
    }
    class City extends WorldObject {
        constructor(x, y) {
            super(x, y);
            this.name = generateCityName();
            this.radius = 30;
            this.structures = [];
            this.constructionSite = null;
            this.woodStockpile = 0;
            this.foodStockpile = 0;
        }
        planStructure() { if (this.constructionSite) return; const angle = random(0, Math.PI * 2); const dist = this.radius + 20; const type = this.structures.length % 5 === 4 ? 'monument' : 'dwelling'; this.constructionSite = new Structure(this.x + Math.cos(angle) * dist, this.y + Math.sin(angle) * dist, type); }
        buildStructure() { this.structures.push(this.constructionSite); this.constructionSite = null; }
        draw() {
            ctx.strokeStyle = '#ca8a04';
            ctx.fillStyle = 'rgba(202, 138, 4, 0.1)';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
            ctx.stroke();
            ctx.fill();
            this.structures.forEach(s => s.draw());
            if (this.constructionSite) this.constructionSite.draw();
            // Draw wood stockpile
            for (let i = 0; i < this.woodStockpile; i++) {
                ctx.fillStyle = '#92400e';
                ctx.fillRect(this.x - 25 + (i % 5) * 6, this.y - 15 + Math.floor(i / 5) * 4, 5, 3);
            }
            // Draw food stockpile
            for (let i = 0; i < this.foodStockpile; i++) {
                ctx.fillStyle = '#4ade80';
                ctx.beginPath();
                ctx.arc(this.x + 22 - (i % 5) * 5, this.y - 13 + Math.floor(i/5) * 4, 2, 0, Math.PI*2);
                ctx.fill();
            }
        }
    }

    class Bumble {
        constructor(x, y, generation = 1, parentTraits = null) {
            this.id = Math.random().toString(36).substr(2, 9);
            this.gender = Math.random() > 0.5 ? 'male' : 'female';
            this.firstName = getRandomFirstName(this.gender);
            this.lastName = null;
            this.x = x || random(20, canvas.width - 20); this.y = y || random(20, canvas.height - 20);
            this.baseRadius = 5;
            this.radius = this.baseRadius;
            this.generation = generation;
            this.isZombie = false;
            this.color = this.gender === 'male' ? '#93c5fd' : '#f9a8d4';
            
            if (parentTraits) {
                this.speed = this.mutate(parentTraits.speed);
                this.perception = this.mutate(parentTraits.perception);
                this.lifespan = this.mutate(parentTraits.lifespan, 2);
                this.intelligence = this.mutate(parentTraits.intelligence, 5);
                this.lastName = parentTraits.lastName;
            } else {
                this.speed = random(0.5, 1.5);
                this.perception = random(50, 150);
                this.lifespan = random(8, 12);
                this.intelligence = random(1, 10);
            }
            
            this.age = 0; this.isDead = false; this.vx = 0; this.vy = 0;
            this.target = null; this.heldResource = null; this.reproductionCooldown = 0;
            this.isFounder = false;
            this.isAdult = false;
            this.smoothAngle = 0;
            this.needs = { hunger: 100, energy: 100 };
            this.state = 'wandering';
        }
        
        get fullName() { return this.lastName ? `${this.firstName} ${this.lastName}` : this.firstName; }
        
        mutate(value, range = 1) {
            if (Math.random() < settings.mutationChance) {
                worldStats.mutations++;
                return Math.max(0.1, value + random(-range, range));
            }
            return value;
        }

        updateNeeds() {
            if (this.isZombie && (timeOfDay === 'Day' || timeOfDay === 'Dawn')) {
                this.needs.hunger -= 1.0;
            }
            const baseMetabolism = 0.002;
            const activityCost = (Math.abs(this.vx) + Math.abs(this.vy)) * 0.001;
            const nightPenalty = timeOfDay === 'Night' ? 0.001 : 0;
            this.needs.hunger -= (baseMetabolism + nightPenalty);
            this.needs.energy -= (baseMetabolism + activityCost);
            if (this.needs.energy < 0) {
                 this.needs.hunger += this.needs.energy / 2;
                 this.needs.energy = 0;
            }
            if (timeOfDay !== 'Night' && this.state === 'wandering' && this.needs.energy < 100) {
                this.needs.energy += 0.01;
            }
        }

        updateState() {
            if (this.isZombie) { this.state = 'hunting'; return; }
            
            const nearestZombie = this.findClosest(bumbles.filter(b => b.isZombie), this.perception, false);
            if (nearestZombie) { this.state = 'fleeing'; this.target = nearestZombie; return; }

            const founder = bumbles.find(b => b.isFounder);
            const fleeTarget = this.findClosest(resources.filter(r => r instanceof Fire), this.perception, false);
            if (fleeTarget) { this.state = 'fleeing'; this.target = fleeTarget; return; }
            
            if (this.needs.hunger < 40) { this.state = 'seekingFood'; }
            else if (this.isAdult && this.needs.hunger > 80 && this.reproductionCooldown <= 0 && this.age < this.lifespan * 0.8 && Math.random() < settings.reproductionUrge) { this.state = 'seekingMate'; }
            else if (this.isAdult && day > 1 && this.intelligence > 15 && cities.length === 0) {
                if (!founder && !this.isFounder) { this.state = 'planning'; } 
                else if (founder && this.id !== founder.id) { this.state = 'assisting'; }
            }
            else if (this.isAdult && this.intelligence > 15) {
                if (this.heldResource === 'wood') { this.state = 'depositingWood'; } 
                else if (this.heldResource === 'food') { this.state = 'depositingFood'; }
                else if (!this.heldResource) {
                    const nearestCity = this.findClosest(cities, this.perception * 2, false);
                    if (nearestCity) {
                        if (nearestCity.constructionSite && nearestCity.woodStockpile > 0) { this.state = 'building'; }
                        else if (Math.random() > 0.5) { this.state = 'harvesting'; }
                        else { this.state = 'foraging'; }
                    } else { this.state = 'wandering'; }
                }
            }
            else if (this.state !== 'wandering') { this.state = 'wandering'; }
        }
        
        performAction() {
            this.target = null;
            switch (this.state) {
                case 'hunting':
                    this.findClosest(bumbles.filter(b => !b.isZombie && !b.isDead), this.perception * 2, true);
                    break;
                case 'seekingFood':
                    const nearestCityWithFood = this.findClosest(cities.filter(c => c.foodStockpile > 0), this.perception * 2, false);
                    if (nearestCityWithFood) { this.target = nearestCityWithFood; } 
                    else { this.findClosest(foods, this.perception, true); }
                    break;
                case 'seekingMate':
                    const potentialMates = bumbles.filter(b => b.id !== this.id && b.isAdult && b.gender !== this.gender && !b.isDead && b.reproductionCooldown <= 0);
                    this.findClosest(potentialMates, this.perception, true);
                    break;
                case 'harvesting':
                    this.findClosest(resources.filter(r => r instanceof Tree), this.perception * 1.5, true);
                    break;
                case 'foraging':
                    this.findClosest(foods, this.perception * 1.5, true);
                    break;
                case 'depositingWood':
                case 'depositingFood':
                    this.findClosest(cities, this.perception * 2, true);
                    break;
                case 'building':
                    const nearestCity = this.findClosest(cities, this.perception * 2, false);
                    if (nearestCity && nearestCity.constructionSite) { this.target = nearestCity; } 
                    else { this.state = 'wandering'; }
                    break;
                case 'planning':
                    this.isFounder = true; this.vx = 0; this.vy = 0;
                    break;
                case 'assisting':
                    this.target = bumbles.find(b => b.isFounder);
                    break;
                case 'fleeing':
                    break;
                case 'wandering':
                default:
                    if (Math.random() < 0.02) { this.vx = random(-this.speed*0.5, this.speed*0.5); this.vy = random(-this.speed*0.5, this.speed*0.5); }
                    break;
            }
        }

        findClosest(targets, range, setTarget = true) {
            let closest = null, minDist = range;
            for (const t of targets) {
                if (!t || t.isDead) continue;
                const d = getDistance(this.x, this.y, t.x, t.y);
                if (d < minDist) { minDist = d; closest = t; }
            }
            if (setTarget) this.target = closest;
            return closest;
        }

        update() {
            if (this.isDead) return;
            this.age += 1 / framesPerDay;
            if (!this.isAdult && this.age > 2) {
                this.isAdult = true;
                this.baseRadius = random(8, 12);
            }
            this.updateNeeds();
            if (this.needs.hunger <= 0 || this.age >= this.lifespan) { this.die(); return; }
            if (this.reproductionCooldown > 0) this.reproductionCooldown--;

            if (frameCount % 60 === 0) this.updateState();
            this.performAction();

            const effectiveSpeed = this.isZombie ? this.speed * 0.7 : this.speed * (this.needs.energy / 100);
            if (this.target) {
                const angle = Math.atan2(this.target.y - this.y, this.target.x - this.x);
                if (this.state === 'fleeing') {
                    this.vx = -Math.cos(angle) * this.speed;
                    this.vy = -Math.sin(angle) * this.speed;
                } else {
                    this.vx = Math.cos(angle) * effectiveSpeed;
                    this.vy = Math.sin(angle) * effectiveSpeed;
                }
            } else if (this.state !== 'wandering' && this.state !== 'planning') {
                if (Math.random() < 0.05) { this.vx = random(-this.speed*0.2, this.speed*0.2); this.vy = random(-this.speed*0.2, this.speed*0.2); }
            }
            
            this.x += this.vx; this.y += this.vy;
            if (this.x < this.radius || this.x > canvas.width - this.radius) this.vx *= -1;
            if (this.y < this.radius || this.y > canvas.height - this.radius) this.vy *= -1;

            this.radius = this.baseRadius + Math.sin(frameCount * 0.1) * 0.5;
            let targetAngle = Math.atan2(this.vy, this.vx);
            if (Math.abs(this.vx) < 0.1 && Math.abs(this.vy) < 0.1) targetAngle = this.smoothAngle || 0;
            let angleDiff = targetAngle - (this.smoothAngle || 0);
            while (angleDiff < -Math.PI) angleDiff += 2 * Math.PI;
            while (angleDiff > Math.PI) angleDiff -= 2 * Math.PI;
            this.smoothAngle = (this.smoothAngle || 0) + angleDiff * 0.1;
        }

        reproduce(partner) {
            if (this.isZombie || partner.isZombie || !this.isAdult || !partner.isAdult) return;
            if (this.needs.hunger > 60 && partner.needs.hunger > 60 && this.reproductionCooldown <= 0 && partner.reproductionCooldown <= 0) {
                const energyCost = 30;
                const cooldown = 500;
                this.needs.hunger -= energyCost; partner.needs.hunger -= energyCost;
                this.reproductionCooldown = cooldown; partner.reproductionCooldown = cooldown;
                let familyName = this.lastName || partner.lastName || getRandomLastName();
                this.lastName = familyName; partner.lastName = familyName;
                const childTraits = { speed: (this.speed + partner.speed) / 2, perception: (this.perception + partner.perception) / 2, lifespan: (this.lifespan + partner.lifespan) / 2, intelligence: (this.intelligence + partner.intelligence) / 2, lastName: familyName };
                const childGen = Math.max(this.generation, partner.generation) + 1;
                bumbles.push(new Bumble(this.x, this.y, childGen, childTraits));
            }
        }
        
        die() { this.isDead = true; worldStats.deaths++; }
        
        draw() {
            ctx.beginPath();
            ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
            ctx.fillStyle = this.isZombie ? '#4ade80' : this.color;
            if (this.isFounder) {
                ctx.strokeStyle = '#fde047';
                ctx.lineWidth = 3;
                ctx.stroke();
            }
            ctx.fill();
            if (this.heldResource === 'wood') {
                ctx.fillStyle = '#92400e';
                ctx.fillRect(this.x - 5, this.y - this.radius - 5, 10, 5);
            } else if (this.heldResource === 'food') {
                ctx.fillStyle = '#4ade80';
                ctx.beginPath();
                ctx.arc(this.x, this.y - this.radius - 3, 3, 0, Math.PI*2);
                ctx.fill();
            }
            const angle = this.smoothAngle || 0;
            const eye1X = this.x + Math.cos(angle - 0.6) * this.radius * 0.5, eye1Y = this.y + Math.sin(angle - 0.6) * this.radius * 0.5;
            const eye2X = this.x + Math.cos(angle + 0.6) * this.radius * 0.5, eye2Y = this.y + Math.sin(angle + 0.6) * this.radius * 0.5;
            const eyeRadius = this.radius * 0.3;
            ctx.beginPath(); ctx.arc(eye1X, eye1Y, eyeRadius, 0, Math.PI * 2); ctx.fillStyle = 'white'; ctx.fill();
            ctx.beginPath(); ctx.arc(eye2X, eye2Y, eyeRadius, 0, Math.PI * 2); ctx.fillStyle = 'white'; ctx.fill();
            if (!this.isZombie) {
                const eyeOffsetX = Math.cos(angle) * this.radius * 0.3, eyeOffsetY = Math.sin(angle) * this.radius * 0.3;
                const pupilRadius = eyeRadius * 0.5;
                ctx.beginPath(); ctx.arc(eye1X + eyeOffsetX, eye1Y + eyeOffsetY, pupilRadius, 0, Math.PI * 2); ctx.fillStyle = 'black'; ctx.fill();
                ctx.beginPath(); ctx.arc(eye2X + eyeOffsetX, eye2Y + eyeOffsetY, pupilRadius, 0, Math.PI * 2); ctx.fillStyle = 'black'; ctx.fill();
            }
        }
    }

    // --- SIMULATION CORE LOGIC ---
    function init() {
        const container = document.getElementById('simulation-container'); canvas.width = container.clientWidth; canvas.height = container.clientHeight;
        bumbles = []; foods = []; resources = []; cities = []; day = 0; frameCount = 0; worldStats = { deaths: 0, mutations: 0 };
        for (let i = 0; i < settings.initialPopulation; i++) bumbles.push(new Bumble());
        camera.x = canvas.width / 2;
        camera.y = canvas.height / 2;
        camera.scale = 1;
        updateDayNightCycle(true);
    }

    function updateDayNightCycle(force = false) {
        const dayProgress = (frameCount % framesPerDay) / framesPerDay;
        let newTimeOfDay = 'Day';
        if (dayProgress > 0.9) newTimeOfDay = 'Dawn';
        else if (dayProgress > 0.5) newTimeOfDay = 'Night';
        else if (dayProgress > 0.4) newTimeOfDay = 'Dusk';
        
        if (newTimeOfDay !== timeOfDay || force) {
            timeOfDay = newTimeOfDay;
            let bgStyle;
            switch (timeOfDay) {
                case 'Day': bgStyle = `radial-gradient(ellipse at bottom, var(--ground-color) 0%, var(--sky-horizon) 100%)`; break;
                case 'Dusk': bgStyle = `radial-gradient(ellipse at bottom, #1e293b 0%, #4338ca 100%)`; break;
                case 'Night': bgStyle = `radial-gradient(ellipse at bottom, #0f172a 0%, #020617 100%)`; break;
                case 'Dawn': bgStyle = `radial-gradient(ellipse at bottom, #1e293b 0%, #f97316 100%)`; break;
            }
            simulationContainer.style.background = bgStyle;
        }
    }
    
    function checkCityFormation() {
        if (cities.length > 0) return;
        const founder = bumbles.find(b => b.isFounder);
        if (founder) {
            const assistants = bumbles.filter(b => b.id !== founder.id && getDistance(b.x, b.y, founder.x, founder.y) < 30);
            if (assistants.length >= 2) {
                cities.push(new City(founder.x, founder.y));
                founder.isFounder = false;
                founder.state = 'harvesting';
                assistants.forEach(a => a.state = 'harvesting');
            }
        }
    }

    function updateSimulation() {
        if (frameCount % settings.foodSpawnInterval === 0) foods.push(new Food(random(0, canvas.width), random(0, canvas.height)));
        if (frameCount % 500 === 0) resources.push(new Tree(random(0, canvas.width), random(0, canvas.height)));
        
        bumbles.forEach(b => b.update());
        if (frameCount % 10 === 0) checkCityFormation();

        for (let i = bumbles.length - 1; i >= 0; i--) {
            const b = bumbles[i];
            if (b.isDead) continue;
            
            // Resource & Food Interactions
            for (let j = foods.length - 1; j >= 0; j--) { 
                if (getDistance(b.x, b.y, foods[j].x, foods[j].y) < b.radius) { 
                    if (b.state === 'seekingFood') {
                        b.needs.hunger = Math.min(100, b.needs.hunger + foods[j].energy);
                    } else if (b.state === 'foraging' && !b.heldResource) {
                        b.heldResource = 'food';
                    }
                    b.target = null; 
                    foods.splice(j, 1);
                    break; 
                } 
            }
            for (let j = resources.length - 1; j >= 0; j--) {
                const r = resources[j];
                if (r instanceof Tree && getDistance(b.x, b.y, r.x, r.y) < b.radius + r.radius && !b.heldResource && b.state === 'harvesting') {
                    r.woodAmount--;
                    b.heldResource = 'wood';
                    if (r.woodAmount <= 0) resources.splice(j, 1);
                    b.target = null;
                }
            }
            // City Interactions
            for (let j = cities.length - 1; j >= 0; j--) {
                const c = cities[j];
                if (getDistance(b.x, b.y, c.x, c.y) < c.radius) {
                    if (b.heldResource === 'wood' && b.state === 'depositingWood') {
                        c.woodStockpile++; b.heldResource = null; b.target = null;
                    } else if (b.heldResource === 'food' && b.state === 'depositingFood') {
                        c.foodStockpile++; b.heldResource = null; b.target = null;
                    } else if (b.state === 'seekingFood' && c.foodStockpile > 0) {
                        c.foodStockpile--; b.needs.hunger = 100; b.target = null; b.state = 'wandering';
                    } else if (b.state === 'building' && !b.heldResource && c.woodStockpile > 0) {
                        c.woodStockpile--; b.heldResource = 'wood'; b.target = c.constructionSite;
                    }
                }
                
                if (c.constructionSite && getDistance(b.x, b.y, c.constructionSite.x, c.constructionSite.y) < b.radius && b.heldResource === 'wood') {
                    b.heldResource = null;
                    c.constructionSite.addWood();
                    b.intelligence += 0.2;
                    if (c.constructionSite.isComplete) c.buildStructure();
                    b.target = null;
                }
            }

            // Bumble-Bumble Interactions
            for (let j = i + 1; j < bumbles.length; j++) {
                const b2 = bumbles[j];
                if (b2.isDead) continue;
                if (getDistance(b.x, b.y, b2.x, b2.y) < b.radius + b2.radius) {
                    if (b.isZombie && !b2.isZombie) b2.isZombie = true;
                    if (b2.isZombie && !b.isZombie) b.isZombie = true;
                    if (!b.isZombie && !b2.isZombie && b.gender !== b2.gender) b.reproduce(b2);
                }
            }
        }
        
        bumbles = bumbles.filter(b => !b.isDead);
        frameCount++; day = frameCount / framesPerDay;
        if (frameCount % 60 === 0) updateDayNightCycle(false);
    }
    
    function drawSimulation() {
        ctx.save();
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.translate(camera.x, camera.y);
        ctx.scale(camera.scale, camera.scale);
        
        foods.forEach(f => f.draw());
        resources.forEach(r => { if (r.update) r.update(); r.draw(); });
        cities.forEach(c => c.draw());
        bumbles.forEach(b => b.draw());
        
        ctx.restore();
    }

    function animate() {
        if (!isRunning) return;
        for (let i = 0; i < settings.timeMultiplier; i++) { updateSimulation(); }
        drawSimulation();
        if (frameCount % 30 === 0) updateUI();
        animationFrameId = requestAnimationFrame(animate);
    }

    function updateUI() {
        populationStat.textContent = bumbles.length;
        dayStat.textContent = Math.floor(day);
        timeOfDayStat.textContent = timeOfDay;
        citiesStat.textContent = cities.length;
        const familyNames = [...new Set(bumbles.filter(b => b.lastName).map(b => b.lastName))];
        familiesCountStat.textContent = familyNames.length;
        if (familyNames.length > 0) {
            familyListStat.innerHTML = familyNames.sort().join('<br>');
        } else {
            familyListStat.textContent = 'None';
        }
    }

    function makeDraggable(panel) {
        const handle = panel.querySelector('.drag-handle');
        let isDragging = false;
        let offsetX, offsetY;
        handle.addEventListener('mousedown', (e) => {
            isDragging = true;
            offsetX = e.clientX - panel.getBoundingClientRect().left;
            offsetY = e.clientY - panel.getBoundingClientRect().top;
            handle.style.cursor = 'grabbing';
            panel.style.transition = 'none';
        });
        window.addEventListener('mousemove', (e) => {
            if (!isDragging) return;
            let newX = e.clientX - offsetX;
            let newY = e.clientY - offsetY;
            const containerRect = document.getElementById('simulation-container').getBoundingClientRect();
            newX = Math.max(0, Math.min(newX, containerRect.width - panel.offsetWidth));
            newY = Math.max(0, Math.min(newY, containerRect.height - panel.offsetHeight));
            panel.style.left = `${newX}px`;
            panel.style.top = `${newY}px`;
            panel.style.transform = '';
        });
        window.addEventListener('mouseup', () => {
            isDragging = false;
            handle.style.cursor = 'grab';
            panel.style.transition = '';
        });
    }
    makeDraggable(document.getElementById('stats-panel'));
    makeDraggable(document.getElementById('tool-panel'));
    
    // --- EVENT LISTENERS ---
    function togglePlayPause() {
        isRunning = !isRunning;
        playIcon.classList.toggle('hidden');
        pauseIcon.classList.toggle('hidden');
        playPauseBtn.classList.toggle('paused');
        if (isRunning) animate();
        else cancelAnimationFrame(animationFrameId);
    }

    function showBumbleInfo(bumble) {
        bumbleName.textContent = bumble.fullName;
        bumbleGeneration.textContent = bumble.generation;
        bumbleGender.textContent = bumble.gender.charAt(0).toUpperCase() + bumble.gender.slice(1);
        bumbleGender.style.color = bumble.gender === 'male' ? '#93c5fd' : '#f9a8d4';
        bumbleAge.textContent = `${bumble.age.toFixed(1)} / ${bumble.lifespan.toFixed(0)} days`; 
        bumbleEnergyBar.style.width = `${bumble.needs.hunger}%`;
        bumbleOccupation.textContent = bumble.state.charAt(0).toUpperCase() + bumble.state.slice(1);
        bumbleHolding.textContent = bumble.heldResource || 'Nothing';
        bumbleInfoModal.classList.add('visible');
    }

    startScreen.addEventListener('click', () => {
        startScreen.style.opacity = '0';
        setTimeout(() => startScreen.style.display = 'none', 500);
        if (!isRunning) togglePlayPause();
    }, { once: true });

    playPauseBtn.addEventListener('click', togglePlayPause);
    restartBtn.addEventListener('click', () => { if(isRunning) togglePlayPause(); init(); updateUI(); drawSimulation(); });
    settingsBtn.addEventListener('click', () => settingsModal.classList.add('visible'));
    closeSettingsBtn.addEventListener('click', () => settingsModal.classList.remove('visible'));
    
    zombieBtn.addEventListener('click', () => {
        if (!isRunning) return;
        const worldPos = screenToWorld(canvas.width / 2, canvas.height / 2);
        const newZombie = new Bumble(worldPos.x, worldPos.y);
        newZombie.isZombie = true;
        bumbles.push(newZombie);
    });

    collapseStatsBtn.addEventListener('click', (e) => {
        e.stopPropagation();
        statsPanel.classList.toggle('collapsed');
        collapseStatsBtn.querySelector('svg').style.transform = statsPanel.classList.contains('collapsed') ? 'rotate(180deg)' : 'rotate(0deg)';
    });
    
    initialPopSlider.addEventListener('input', (e) => { settings.initialPopulation = parseInt(e.target.value); initialPopValue.textContent = e.target.value; });
    foodIntervalSlider.addEventListener('input', (e) => { settings.foodSpawnInterval = parseInt(e.target.value); foodIntervalValue.textContent = e.target.value; });
    reproductionRateSlider.addEventListener('input', (e) => { settings.reproductionUrge = parseInt(e.target.value) / 100; reproductionRateValue.textContent = `${e.target.value}%`; });
    mutationRateSlider.addEventListener('input', (e) => { settings.mutationChance = parseInt(e.target.value) / 100; mutationRateValue.textContent = `${e.target.value}%`; });
    timeSpeedSlider.addEventListener('input', (e) => { settings.timeMultiplier = parseInt(e.target.value); timeSpeedValue.textContent = `${e.target.value}x`; });
    
    toolBtns.forEach(btn => {
        btn.addEventListener('click', () => {
            const tool = btn.dataset.tool;
            if (activeTool === tool) { activeTool = null; btn.classList.remove('active'); canvas.style.cursor = 'grab'; }
            else { activeTool = tool; toolBtns.forEach(b => b.classList.remove('active')); btn.classList.add('active'); canvas.style.cursor = 'copy'; }
        });
    });

    function screenToWorld(x, y) {
        return {
            x: (x - camera.x) / camera.scale,
            y: (y - camera.y) / camera.scale
        };
    }

    canvas.addEventListener('wheel', (e) => {
        e.preventDefault();
        const zoomIntensity = 0.1;
        const wheel = e.deltaY < 0 ? 1 : -1;
        const zoom = Math.exp(wheel * zoomIntensity);
        const mousePos = { x: e.clientX, y: e.clientY };
        camera.x = mousePos.x - (mousePos.x - camera.x) * zoom;
        camera.y = mousePos.y - (mousePos.y - camera.y) * zoom;
        camera.scale *= zoom;
        camera.scale = Math.max(0.2, Math.min(3, camera.scale));
        if (!isRunning) drawSimulation();
    }, { passive: false });

    let panStart = { x: 0, y: 0 };
    canvas.addEventListener('mousedown', (e) => {
        panStart.x = e.clientX;
        panStart.y = e.clientY;
        const worldPos = screenToWorld(e.clientX, e.clientY);
        const clickedBumble = bumbles.find(b => getDistance(worldPos.x, worldPos.y, b.x, b.y) < b.radius);
        if (!clickedBumble && !activeTool) {
            camera.isPanning = true;
            camera.lastPanX = e.clientX;
            camera.lastPanY = e.clientY;
        }
    });

    canvas.addEventListener('mousemove', (e) => {
        if (camera.isPanning) {
            const dx = e.clientX - camera.lastPanX;
            const dy = e.clientY - camera.lastPanY;
            camera.x += dx;
            camera.y += dy;
            camera.lastPanX = e.clientX;
            camera.lastPanY = e.clientY;
            if (!isRunning) drawSimulation();
        }
    });

    canvas.addEventListener('mouseup', (e) => {
        camera.isPanning = false;
        const dist = getDistance(panStart.x, panStart.y, e.clientX, e.clientY);
        if (dist > 5) return; // It was a drag, not a click

        const worldPos = screenToWorld(e.clientX, e.clientY);
        if (activeTool) {
            if (activeTool === 'food') foods.push(new Food(worldPos.x, worldPos.y));
            if (activeTool === 'tree') resources.push(new Tree(worldPos.x, worldPos.y));
            if (activeTool === 'fire') resources.push(new Fire(worldPos.x, worldPos.y));
            if (activeTool === 'bumble') bumbles.push(new Bumble(worldPos.x, worldPos.y));
            if (!isRunning) drawSimulation();
            return;
        }
        
        const clickedBumble = bumbles.find(b => getDistance(worldPos.x, worldPos.y, b.x, b.y) < b.radius);
        if (clickedBumble) showBumbleInfo(clickedBumble);
    });
    canvas.addEventListener('mouseleave', () => { camera.isPanning = false; });

    canvas.addEventListener('touchstart', (e) => {
        if (e.touches.length === 1) {
            camera.isPanning = true;
            camera.lastPanX = e.touches[0].clientX;
            camera.lastPanY = e.touches[0].clientY;
        } else if (e.touches.length === 2) {
            camera.isPanning = false;
            const dx = e.touches[0].clientX - e.touches[1].clientX;
            const dy = e.touches[0].clientY - e.touches[1].clientY;
            camera.lastTouchDist = Math.sqrt(dx * dx + dy * dy);
        }
    });

    canvas.addEventListener('touchmove', (e) => {
        e.preventDefault();
        if (e.touches.length === 1 && camera.isPanning) {
            const dx = e.touches[0].clientX - camera.lastPanX;
            const dy = e.touches[0].clientY - camera.lastPanY;
            camera.x += dx;
            camera.y += dy;
            camera.lastPanX = e.touches[0].clientX;
            camera.lastPanY = e.touches[0].clientY;
        } else if (e.touches.length === 2) {
            const dx = e.touches[0].clientX - e.touches[1].clientX;
            const dy = e.touches[0].clientY - e.touches[1].clientY;
            const currentDist = Math.sqrt(dx * dx + dy * dy);
            const zoom = currentDist / camera.lastTouchDist;
            const touchMidpoint = { x: (e.touches[0].clientX + e.touches[1].clientX) / 2, y: (e.touches[0].clientY + e.touches[1].clientY) / 2 };
            camera.x = touchMidpoint.x - (touchMidpoint.x - camera.x) * zoom;
            camera.y = touchMidpoint.y - (touchMidpoint.y - camera.y) * zoom;
            camera.scale *= zoom;
            camera.scale = Math.max(0.2, Math.min(3, camera.scale));
            camera.lastTouchDist = currentDist;
        }
        if (!isRunning) drawSimulation();
    }, { passive: false });

    canvas.addEventListener('touchend', () => {
        camera.isPanning = false;
        camera.lastTouchDist = 0;
    });

    closeInfoBtn.addEventListener('click', () => bumbleInfoModal.classList.remove('visible'));
    [bumbleInfoModal, settingsModal].forEach(modal => { modal.addEventListener('click', (e) => { if (e.target === modal) modal.classList.remove('visible'); }); });

    window.addEventListener('resize', () => {
        const wasRunning = isRunning;
        if (wasRunning) { isRunning = false; cancelAnimationFrame(animationFrameId); }
        init();
        if (wasRunning) {
            isRunning = true;
            playPauseBtn.classList.remove('paused');
            playIcon.classList.add('hidden');
            pauseIcon.classList.remove('hidden');
            animate();
        } else {
             playPauseBtn.classList.add('paused');
             playIcon.classList.remove('hidden');
             pauseIcon.classList.add('hidden');
             drawSimulation();
             updateUI();
        }
    });

    // --- Initial Setup ---
    init();
    drawSimulation();
    updateUI();
});
</script>
</body>
</html>